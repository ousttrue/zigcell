const std = @import("std");
pub const WHITE = [3]f32{ 1, 1, 1 };
pub const GRAY = [3]f32{ 0.5, 0.5, 0.5 };
pub const RED = [3]f32{ 1, 0, 0 };
pub const GREEN = [3]f32{ 0, 1, 0 };
pub const BLUE = [3]f32{ 0, 0, 1 };
pub const CYAN = [3]f32{ 0, 1, 1 };
pub const MAGENTA = [3]f32{ 1, 0, 1 };
pub const YELLOW = [3]f32{ 1, 1, 0 };

pub fn isInToken(pos: usize, token: std.zig.Token) bool {
    return pos >= token.loc.start and pos <= token.loc.end-1;
}

pub fn tagColor(tag: std.zig.Token.Tag) [3]f32 {
    return switch (tag) {
        .invalid => .{ 1, 1, 1 },
        .invalid_periodasterisks => .{ 1, 1, 1 },
        .identifier => GREEN,

        .string_literal,
        .multiline_string_literal_line,
        .char_literal,
        => MAGENTA,

        .eof => .{ 1, 1, 1 },
        .builtin => YELLOW,

        .bang,
        .pipe,
        .pipe_pipe,
        .pipe_equal,
        .equal,
        .equal_equal,
        .equal_angle_bracket_right,
        .bang_equal,
        .l_paren,
        .r_paren,
        .semicolon,
        .percent,
        .percent_equal,
        .l_brace,
        .r_brace,
        .l_bracket,
        .r_bracket,
        .period,
        .period_asterisk,
        .ellipsis2,
        .ellipsis3,
        .caret,
        .caret_equal,
        .plus,
        .plus_plus,
        .plus_equal,
        .plus_percent,
        .plus_percent_equal,
        .plus_pipe,
        .plus_pipe_equal,
        .minus,
        .minus_equal,
        .minus_percent,
        .minus_percent_equal,
        .minus_pipe,
        .minus_pipe_equal,
        .asterisk,
        .asterisk_equal,
        .asterisk_asterisk,
        .asterisk_percent,
        .asterisk_percent_equal,
        .asterisk_pipe,
        .asterisk_pipe_equal,
        .arrow,
        .colon,
        .slash,
        .slash_equal,
        .comma,
        .ampersand,
        .ampersand_equal,
        .question_mark,
        .angle_bracket_left,
        .angle_bracket_left_equal,
        .angle_bracket_angle_bracket_left,
        .angle_bracket_angle_bracket_left_equal,
        .angle_bracket_angle_bracket_left_pipe,
        .angle_bracket_angle_bracket_left_pipe_equal,
        .angle_bracket_right,
        .angle_bracket_right_equal,
        .angle_bracket_angle_bracket_right,
        .angle_bracket_angle_bracket_right_equal,
        .tilde,
        => CYAN,

        .integer_literal,
        .float_literal,
        => MAGENTA,

        .doc_comment => .{ 1, 1, 1 },
        .container_doc_comment => .{ 1, 1, 1 },

        .keyword_addrspace,
        .keyword_align,
        .keyword_allowzero,
        .keyword_and,
        .keyword_anyframe,
        .keyword_anytype,
        .keyword_asm,
        .keyword_async,
        .keyword_await,
        .keyword_break,
        .keyword_callconv,
        .keyword_catch,
        .keyword_comptime,
        .keyword_const,
        .keyword_continue,
        .keyword_defer,
        .keyword_else,
        .keyword_enum,
        .keyword_errdefer,
        .keyword_error,
        .keyword_export,
        .keyword_extern,
        .keyword_fn,
        .keyword_for,
        .keyword_if,
        .keyword_inline,
        .keyword_noalias,
        .keyword_noinline,
        .keyword_nosuspend,
        .keyword_opaque,
        .keyword_or,
        .keyword_orelse,
        .keyword_packed,
        .keyword_pub,
        .keyword_resume,
        .keyword_return,
        .keyword_linksection,
        .keyword_struct,
        .keyword_suspend,
        .keyword_switch,
        .keyword_test,
        .keyword_threadlocal,
        .keyword_try,
        .keyword_union,
        .keyword_unreachable,
        .keyword_usingnamespace,
        .keyword_var,
        .keyword_volatile,
        .keyword_while,
        => CYAN,
    };
}

pub fn getTokenColor(bytePos: usize, token: std.zig.Token) [3]f32 {
    return if (isInToken(bytePos, token)) tagColor(token.tag) else GRAY;
}
